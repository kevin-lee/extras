"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6863],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>v});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=s(t),u=i,v=m["".concat(p,".").concat(u)]||m[u]||c[u]||r;return t?a.createElement(v,l(l({ref:n},d),{},{components:t})):a.createElement(v,l({ref:n},d))}));function v(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=u;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[m]="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3893:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={sidebar_position:1,id:"refinement",title:"refinement Syntax"},l=void 0,o={unversionedId:"extras-refinement/syntax/refinement",id:"extras-refinement/syntax/refinement",title:"refinement Syntax",description:"Why refinement syntax?",source:"@site/../generated-docs/docs/extras-refinement/syntax/refinement.md",sourceDirName:"extras-refinement/syntax",slug:"/extras-refinement/syntax/refinement",permalink:"/docs/extras-refinement/syntax/refinement",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,id:"refinement",title:"refinement Syntax"},sidebar:"tutorialSidebar",previous:{title:"syntax",permalink:"/docs/extras-refinement/syntax/"},next:{title:"string Syntax",permalink:"/docs/extras-refinement/syntax/string"}},p={},s=[{value:"Why <code>refinement</code> syntax?",id:"why-refinement-syntax",level:2},{value:"<code>validateAs</code>",id:"validateas",level:2},{value:"Example: Valid Case",id:"example-valid-case",level:3},{value:"Example: Invalid Case",id:"example-invalid-case",level:3},{value:"Only of them is invalid",id:"only-of-them-is-invalid",level:4},{value:"The other one is invalid",id:"the-other-one-is-invalid",level:4},{value:"More than one invalid",id:"more-than-one-invalid",level:4},{value:"<code>toValue</code>",id:"tovalue",level:2}],d={toc:s},m="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"why-refinement-syntax"},"Why ",(0,i.kt)("inlineCode",{parentName:"h2"},"refinement")," syntax?"),(0,i.kt)("p",null,"When you use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/estatico/scala-newtype"},"newtype")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/fthomas/refined"},"refined")," together\nto have better type-safety, you often have some boilerplate code for runtime value validation\nwhen creating newtype + refinement type just like this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'YourRefinementType.from(value)\n  .map(YourNewtype(_))\n  .leftMap(err => s"Failed to create YourNewtype: $err")\n  .toEitherNec\n')),(0,i.kt)("p",null,"There are a few issues here."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"First, you need to create your ",(0,i.kt)("inlineCode",{parentName:"li"},"newtype")," with the newtype constructor and the validated value. e.g.) ",(0,i.kt)("inlineCode",{parentName:"li"},".map(YourNewType(_))")),(0,i.kt)("li",{parentName:"ul"},"If it is invalid, you probably want to add the type name for debugging with ",(0,i.kt)("inlineCode",{parentName:"li"},"leftMap"),". e.g.) ",(0,i.kt)("inlineCode",{parentName:"li"},'.leftMap(err => s"Failed to create YourNewtype: $err")')),(0,i.kt)("li",{parentName:"ul"},"Finally, depending on how to validate, you probably turn the ",(0,i.kt)("inlineCode",{parentName:"li"},"Either[String, YourNewType]")," from the validation into ",(0,i.kt)("inlineCode",{parentName:"li"},"EitherNec")," since you may want to accumulate all the errors from multiple validations. e.g.) ",(0,i.kt)("inlineCode",{parentName:"li"},".toEitherNec"))),(0,i.kt)("p",null,"In practice, it may look like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport io.estatico.newtype.macros.newtype\nimport eu.timepit.refined.types.string.NonEmptyString\n\n@newtype case class Name(value: NonEmptyString)\n\nval validNameValue = "Kevin"\n// validNameValue: String = "Kevin"\nNonEmptyString.from(validNameValue)\n  .map(Name(_))\n  .leftMap(err => s"Failed to create Name: $err")\n  .toEitherNec\n// res1: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\n\nval invalidNameValue = ""\n// invalidNameValue: String = ""\nNonEmptyString.from(invalidNameValue)\n  .map(Name(_))\n  .leftMap(err => s"Failed to create Name: $err")\n  .toEitherNec\n// res2: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Name: Predicate isEmpty() did not fail."\n//   )\n// )\n')),(0,i.kt)("p",null,"or this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\nimport io.estatico.newtype.ops._\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Id(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n  final case class Person(id: Id, name: Name)\n}\nimport Types._\n\nval idValue = 999\n// idValue: Int = 999\n\nval id = PositiveInt.from(idValue)\n          .map(Id(_))\n          .leftMap(err => s"Failed to create Types.Id: $err")\n          .toEitherNec\n// id: cats.data.package.EitherNec[String, Id] = Right(value = 999)\nprintln(id)\n// Right(999)\n\nval nameValue = "Kevin"\n// nameValue: String = "Kevin"\n\nval name = NonEmptyString.from(nameValue)\n            .map(Name(_))\n            .leftMap(err => s"Failed to create Types.Name: $err")\n            .toEitherNec\n// name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\nprintln(name)\n// Right(Kevin)\n\nval person = (id, name).parMapN(Person.apply)\n// person: cats.data.package.EitherNec[String, Person] = Right(\n//   value = Person(id = 999, name = Kevin)\n// )\nprintln(person)\n// Right(Person(999,Kevin))\n')),(0,i.kt)("p",null,"or invalid case like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val idValue2 = 0\n// idValue2: Int = 0\n\nval id2 = PositiveInt.from(idValue2)\n          .map(Id(_))\n          .leftMap(err => s"Failed to create Types.Id: $err")\n          .toEitherNec\n// id2: cats.data.package.EitherNec[String, Id] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nprintln(id2)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\n\nval nameValue2 = ""\n// nameValue2: String = ""\n\nval name2 = NonEmptyString.from(nameValue2)\n            .map(Name(_))\n            .leftMap(err => s"Failed to create Types.Name: $err")\n            .toEitherNec\n// name2: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nprintln(name2)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\n\nval person2 = (id2, name2).parMapN(Person.apply)\n// person2: cats.data.package.EitherNec[String, Person] = Left(\n//   value = Append(\n//     leftNE = Singleton(\n//       a = "Failed to create Types.Id: Predicate failed: (0 > 0)."\n//     ),\n//     rightNE = Singleton(\n//       a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//     )\n//   )\n// )\nprintln(person2)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0)., Failed to create Types.Name: Predicate isEmpty() did not fail.))\n')),(0,i.kt)("h2",{id:"validateas"},(0,i.kt)("inlineCode",{parentName:"h2"},"validateAs")),(0,i.kt)("p",null,"The boilerplate code issue in newtype + refinement type creation can be fixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"extras")," ",(0,i.kt)("inlineCode",{parentName:"p"},"refinement")," syntax so the following code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'YourRefinementType.from(value)\n  .map(YourNewtype(_))\n  .leftMap(err => s"Failed to create YourNewtype: $err")\n  .toEitherNec\n')),(0,i.kt)("p",null,"becomes just"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"validateAs[YourNewtype](value)\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"value.validateAs[YourNewtype]\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The idea of ",(0,i.kt)("inlineCode",{parentName:"p"},"validateAs[A](value)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"value.validateAs[A]")," is from ",(0,i.kt)("a",{parentName:"p",href:"https://leanpub.com/pfp-scala"},"Practical FP in Scala"),".\nThe syntax is not exactly the same, but the most important core logic of using ",(0,i.kt)("inlineCode",{parentName:"p"},"Coercible")," is the same."),(0,i.kt)("p",{parentName:"admonition"},"If you are interested in the difference,"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/gvolpe/pfps-examples/blob/e49adf61fe5cdc84b0ca50995f20fb5a79f91cea/src/main/scala/examples/validation/RuntimeValidation.scala#L268-L294"},"the source code from ",(0,i.kt)("inlineCode",{parentName:"a"},"Practical FP in Scala")," is here")," and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/kevin-lee/extras/blob/3aaf342368665ba622f41874639e37b4f130a046/modules/extras-refinement/shared/src/main/scala/extras/refinement/syntax/refinement.scala#L11-L42"},"the source code of ",(0,i.kt)("inlineCode",{parentName:"a"},"extras-refinement")," is here")))),(0,i.kt)("h3",{id:"example-valid-case"},"Example: Valid Case"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\nimport extras.refinement.syntax.refinement._\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Id(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n  final case class Person(id: Id, name: Name)\n}\nimport Types._\n\nval idValue = 999\n// idValue: Int = 999\n\nval id  = validateAs[Id](idValue)\n// id: cats.data.package.EitherNec[String, Id] = Right(value = 999)\nval id2 = idValue.validateAs[Id]\n// id2: cats.data.package.EitherNec[String, Id] = Right(value = 999)\nprintln(id)\n// Right(999)\nprintln(id2)\n// Right(999)\n\nval nameValue = "Kevin"\n// nameValue: String = "Kevin"\n\nval name  = validateAs[Name](nameValue)\n// name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\nval name2 = nameValue.validateAs[Name]\n// name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\nprintln(name)\n// Right(Kevin)\nprintln(name2)\n// Right(Kevin)\n\nval person = (id, name).parMapN(Person.apply)\n// person: cats.data.package.EitherNec[String, Person] = Right(\n//   value = Person(id = 999, name = Kevin)\n// )\nprintln(person)\n// Right(Person(999,Kevin))\n')),(0,i.kt)("h3",{id:"example-invalid-case"},"Example: Invalid Case"),(0,i.kt)("h4",{id:"only-of-them-is-invalid"},"Only of them is invalid"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\nimport extras.refinement.syntax.refinement._\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Id(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n  final case class Person(id: Id, name: Name)\n}\nimport Types._\n\nval idValue = 0\n// idValue: Int = 0\n\nval id  = validateAs[Id](idValue)\n// id: cats.data.package.EitherNec[String, Id] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nval id2 = idValue.validateAs[Id]\n// id2: cats.data.package.EitherNec[String, Id] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nprintln(id)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\nprintln(id2)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\n\nval nameValue = "Kevin"\n// nameValue: String = "Kevin"\n\nval name  = validateAs[Name](nameValue)\n// name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\nval name2 = nameValue.validateAs[Name]\n// name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin)\nprintln(name)\n// Right(Kevin)\nprintln(name2)\n// Right(Kevin)\n\nval person = (id, name).parMapN(Person.apply)\n// person: cats.data.package.EitherNec[String, Person] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nprintln(person)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\n')),(0,i.kt)("h4",{id:"the-other-one-is-invalid"},"The other one is invalid"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\nimport extras.refinement.syntax.refinement._\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Id(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n  final case class Person(id: Id, name: Name)\n}\nimport Types._\n\nval idValue = 999\n// idValue: Int = 999\n\nval id  = validateAs[Id](idValue)\n// id: cats.data.package.EitherNec[String, Id] = Right(value = 999)\nval id2 = idValue.validateAs[Id]\n// id2: cats.data.package.EitherNec[String, Id] = Right(value = 999)\nprintln(id)\n// Right(999)\nprintln(id2)\n// Right(999)\n\nval nameValue = ""\n// nameValue: String = ""\n\nval name  = validateAs[Name](nameValue)\n// name: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nval name2 = nameValue.validateAs[Name]\n// name2: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nprintln(name)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\nprintln(name2)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\n\nval person = (id, name).parMapN(Person.apply)\n// person: cats.data.package.EitherNec[String, Person] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nprintln(person)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\n')),(0,i.kt)("h4",{id:"more-than-one-invalid"},"More than one invalid"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.syntax.all._\nimport eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\nimport extras.refinement.syntax.refinement._\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Id(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n  final case class Person(id: Id, name: Name)\n}\nimport Types._\n\nval idValue = 0\n// idValue: Int = 0\n\nval id  = validateAs[Id](idValue)\n// id: cats.data.package.EitherNec[String, Id] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nval id2 = idValue.validateAs[Id]\n// id2: cats.data.package.EitherNec[String, Id] = Left(\n//   value = Singleton(a = "Failed to create Types.Id: Predicate failed: (0 > 0).")\n// )\nprintln(id)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\nprintln(id2)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).))\n\nval nameValue = ""\n// nameValue: String = ""\n\nval name  = validateAs[Name](nameValue)\n// name: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nval name2 = nameValue.validateAs[Name]\n// name2: cats.data.package.EitherNec[String, Name] = Left(\n//   value = Singleton(\n//     a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//   )\n// )\nprintln(name)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\nprintln(name2)\n// Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.))\n\nval person = (id, name).parMapN(Person.apply)\n// person: cats.data.package.EitherNec[String, Person] = Left(\n//   value = Append(\n//     leftNE = Singleton(\n//       a = "Failed to create Types.Id: Predicate failed: (0 > 0)."\n//     ),\n//     rightNE = Singleton(\n//       a = "Failed to create Types.Name: Predicate isEmpty() did not fail."\n//     )\n//   )\n// )\nprintln(person)\n// Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0)., Failed to create Types.Name: Predicate isEmpty() did not fail.))\n')),(0,i.kt)("h2",{id:"tovalue"},(0,i.kt)("inlineCode",{parentName:"h2"},"toValue")),(0,i.kt)("p",null,"If you want to get the underlying value of a refined newtype,\nyou can do it easily with ",(0,i.kt)("inlineCode",{parentName:"p"},"extras.refinement.syntax.refinement"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val name = Name(NonEmptyString("Kevin"))\nname.value\n// NonEmptyString = Kevin\n\nname.value.value\n// String = "Kevin"\n\nimport eu.timepit.refined.auto._\nname.toValue\n// String = "Kevin" \n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import eu.timepit.refined.api._\nimport eu.timepit.refined.numeric._\nimport eu.timepit.refined.types.string.NonEmptyString\nimport io.estatico.newtype.macros.newtype\n\nobject Types {\n  type PositiveInt = Int Refined Positive\n  object PositiveInt extends RefinedTypeOps[PositiveInt, Int]\n  @newtype case class Num(value: PositiveInt)\n  \n  @newtype case class Name(value: NonEmptyString)\n  \n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import Types._\n\ndef foo(n: Int): Int = n * 2\ndef hello(s: String): Unit = println(s"Hello $s")\n\nval n = 1\n// n: Int = 1\nval num = Num(PositiveInt.unsafeFrom(n))\n// num: Num = 1\n\nval nameString = "Kevin"\n// nameString: String = "Kevin"\nval name = Name(NonEmptyString.unsafeFrom(nameString))\n// name: Name = Kevin\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"foo(num.value)\n// error: type mismatch;\n//  found   : repl.MdocSession.MdocApp6.Types.PositiveInt\n//     (which expands to)  eu.timepit.refined.api.Refined[Int,eu.timepit.refined.numeric.Greater[shapeless._0]]\n//  required: Int\n// foo(num.value)\n//     ^^^^^^^^^\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"hello(name.value)\n// error: type mismatch;\n//  found   : eu.timepit.refined.types.string.NonEmptyString\n//     (which expands to)  eu.timepit.refined.api.Refined[String,eu.timepit.refined.boolean.Not[eu.timepit.refined.collection.Empty]]\n//  required: String\n// hello(name.value)\n//       ^^^^^^^^^^\n")),(0,i.kt)("p",null,"You can solve with ",(0,i.kt)("inlineCode",{parentName:"p"},"extras-refinement"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import extras.refinement.syntax.refinement._\n\nnum.value\n// res37: PositiveInt = 1\nnum.value.value\n// res38: Int = 1\nnum.toValue\n// res39: Int = 1\nfoo(num.toValue)\n// res40: Int = 2\n\nname.value\n// res41: NonEmptyString = Kevin\nname.value.value\n// res42: String = "Kevin"\nname.toValue\n// res43: String = "Kevin"\nhello(name.toValue)\n// Hello Kevin\n')),(0,i.kt)("p",null,"You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"eu.timepit.refined.auto")," like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import eu.timepit.refined.auto._\n\nnum.value\n// res45: PositiveInt = 1\nfoo(num.value)\n// res46: Int = 2\n\nname.value\n// res47: NonEmptyString = Kevin\nhello(name.value)\n// Hello Kevin\n")),(0,i.kt)("p",null,"However, ",(0,i.kt)("inlineCode",{parentName:"p"},".value")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"eu.timepit.refined.auto")," does an ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit")," conversion from the ",(0,i.kt)("inlineCode",{parentName:"p"},"refined type")," to the underlying type\nwhereas the syntax from ",(0,i.kt)("inlineCode",{parentName:"p"},"extras-refinement")," is an explicit way to get the underlying type value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"refined newtype"),"."))}c.isMDXComponent=!0}}]);